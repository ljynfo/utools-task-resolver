"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Component = void 0;
const helpers_1 = require("./helpers");
const core_1 = require("./core");
const state_1 = require("./state");
class Component {
    constructor(props) {
        this._elements = [];
        this._skipUnmount = false;
        this._hasUnmounted = false;
        this.props = props || {};
        this.id = this._getHash();
    }
    static isClass() {
        return true;
    }
    setState(state, shouldUpdate = false) {
        const isObject = typeof state === 'object' && state !== null;
        // if state is an object, we merge the objects
        if (isObject && this.state !== undefined)
            this.state = Object.assign(Object.assign({}, this.state), state);
        // else, we just overwrite it
        else
            this.state = state;
        if (shouldUpdate)
            this.update();
    }
    set state(state) {
        state_1._state.set(this.id, state);
    }
    get state() {
        return state_1._state.get(this.id);
    }
    set initState(state) {
        if (this.state === undefined)
            this.state = state;
    }
    /** Returns all currently rendered node elements */
    get elements() {
        return this._elements;
    }
    set elements(elements) {
        if (!Array.isArray(elements))
            elements = [elements];
        elements.forEach(element => {
            this._elements.push(element);
        });
    }
    _addNodeRemoveListener() {
        // check if didUnmount is unused
        if (/^[^{]+{\s+}$/gm.test(this.didUnmount.toString()))
            return;
        // listen if the root elements gets removed
        helpers_1.onNodeRemove(this.elements[0], () => {
            if (!this._skipUnmount)
                this._didUnmount();
        });
    }
    // @ts-ignore
    _didMount() {
        this._addNodeRemoveListener();
        this.didMount();
    }
    _didUnmount() {
        if (this._hasUnmounted)
            return;
        this.didUnmount();
        this._hasUnmounted = true;
    }
    willMount() { }
    didMount() { }
    didUnmount() { }
    render(_update) { }
    /** Will forceRender the component */
    update(update) {
        this._skipUnmount = true;
        // get all current rendered node elements
        const oldElements = [...this.elements];
        // clear
        this._elements = [];
        let el = this.render(update);
        el = core_1._render(el);
        this.elements = el;
        // console.log('old: ', oldElements)
        // console.log('new: ', this.elements)
        // get valid parent node
        const parent = oldElements[0].parentElement;
        // make sure we have a parent
        if (!parent)
            console.warn('Component needs a parent element to get updated!');
        // add all new node elements
        this.elements.forEach((child) => {
            parent.insertBefore(child, oldElements[0]);
        });
        // remove all elements
        oldElements.forEach((child) => {
            child.remove();
            // @ts-ignore
            child = null;
        });
        // listen for node removal
        this._addNodeRemoveListener();
        core_1.tick(() => {
            this._skipUnmount = false;
            if (!this.elements[0].isConnected)
                this._didUnmount();
        });
    }
    _getHash() { }
}
exports.Component = Component;
//# sourceMappingURL=component.js.map