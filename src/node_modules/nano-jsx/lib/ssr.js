"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentSSR = exports.HTMLElementSSR = exports.renderSSR = exports.clearState = exports.initSSR = void 0;
const core_1 = require("./core");
const state_1 = require("./state");
const detectSSR = () => {
    // @ts-ignore
    const isDeno = typeof Deno !== 'undefined';
    const hasWindow = typeof window !== 'undefined' ? true : false;
    return (typeof isSSR !== 'undefined' && isSSR) || isDeno || !hasWindow;
};
// @ts-ignore
globalThis.isSSR = detectSSR() === true ? true : undefined;
// @ts-ignore
globalThis._nano = { isSSR, location: { pathname: '/' } };
const initSSR = (pathname = '/') => {
    // set pathname
    _nano.location = { pathname };
    // @ts-ignore
    globalThis.document = isSSR ? new DocumentSSR() : window.document;
};
exports.initSSR = initSSR;
const clearState = () => {
    state_1._state.clear();
};
exports.clearState = clearState;
const renderSSR = (component, options = {}) => {
    const { pathname, clearState = true } = options;
    exports.initSSR(pathname);
    if (clearState)
        state_1._state.clear();
    return core_1.render(component, null, true).join('');
};
exports.renderSSR = renderSSR;
class HTMLElementSSR {
    constructor(tag) {
        this.isSelfClosing = false;
        this.tagName = tag;
        const selfClosing = [
            'area',
            'base',
            'br',
            'col',
            'embed',
            'hr',
            'img',
            'input',
            'link',
            'meta',
            'param',
            'source',
            'track',
            'wbr'
        ];
        if (selfClosing.indexOf(tag) >= 0) {
            this.ssr = `<${tag} />`;
            this.isSelfClosing = true;
        }
        else {
            this.ssr = `<${tag}></${tag}>`;
        }
    }
    get outerHTML() {
        return this.innerText;
    }
    get innerHTML() {
        var _a, _b;
        const reg = /(^<[a-z]+>)([\s\S]*)(<\/[a-z]+>$)/gm;
        return (_b = (_a = reg.exec(this.ssr)) === null || _a === void 0 ? void 0 : _a[2]) !== null && _b !== void 0 ? _b : '';
    }
    get innerText() {
        var _a, _b;
        const reg = /(^<[^>]+>)(.+)?(<\/[a-z]+>$|\/>$)/gm;
        return (_b = (_a = reg.exec(this.ssr)) === null || _a === void 0 ? void 0 : _a[2]) !== null && _b !== void 0 ? _b : '';
    }
    set innerText(text) {
        const reg = /(^<[^>]+>)(.+)?(<\/[a-z]+>$|\/>$)/gm;
        this.ssr = this.ssr.replace(reg, `$1${text}$3`);
    }
    get attributes() {
        return { length: 1 };
    }
    setAttributeNS(name, value) {
        this.setAttribute(name, value);
    }
    setAttribute(name, value) {
        if (this.isSelfClosing)
            this.ssr = this.ssr.replace(/(^<[a-z]+ )(.+)/gm, `$1${name}="${value}" $2`);
        else
            this.ssr = this.ssr.replace(/(^<[^>]+)(.+)/gm, `$1 ${name}="${value}"$2`);
    }
    appendChild(child) {
        const append = child.ssr ? child.ssr : child;
        const index = this.ssr.lastIndexOf('</');
        this.ssr = this.ssr.substring(0, index) + append + this.ssr.substring(index);
    }
    replaceChild(newChild, _oldChild) {
        this.innerText = newChild.ssr;
    }
    get children() {
        const reg = /<([a-z]+)((?!<\/\1).)*<\/\1>/gms;
        const array = [];
        let match;
        while ((match = reg.exec(this.innerHTML)) !== null) {
            array.push(match[0].replace(/[\s]+/gm, ' '));
        }
        return array;
    }
    addEventListener(_type, _listener, _options) { }
}
exports.HTMLElementSSR = HTMLElementSSR;
class DocumentSSR {
    constructor() {
        this.body = this.createElement('body');
        this.head = this.createElement('head');
    }
    createElement(tag) {
        return new HTMLElementSSR(tag);
    }
    createElementNS(_URI, tag) {
        return new HTMLElementSSR(tag);
    }
    createTextNode(text) {
        return text;
    }
    querySelector(_query) {
        return undefined;
    }
}
exports.DocumentSSR = DocumentSSR;
//# sourceMappingURL=ssr.js.map