"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Link = exports.to = exports.Route = exports.Switch = void 0;
const component_1 = require("../component");
const core_1 = require("../core");
const instances = [];
const register = (comp) => instances.push(comp);
const unregister = (comp) => instances.splice(instances.indexOf(comp), 1);
const historyPush = (path) => {
    window.history.pushState({}, '', path);
    instances.forEach(instance => instance.handlePop());
};
const historyReplace = (path) => {
    window.history.replaceState({}, '', path);
    instances.forEach(instance => instance.handlePop());
};
const matchPath = (pathname, options) => {
    const { exact = false, regex } = options;
    let { path } = options;
    if (!path) {
        return {
            path: null,
            url: pathname,
            isExact: true
        };
    }
    let match;
    let params = {};
    // path with params
    if (path.includes('/:')) {
        const pathArr = path.split('/');
        const pathnameArr = pathname.split('/');
        pathArr.forEach((p, i) => {
            if (/^:/.test(p)) {
                const key = p.slice(1);
                const value = pathnameArr[i];
                // if a regex is provided, check it it matches
                if (regex && regex[key]) {
                    const regexMatch = regex[key].test(value);
                    if (!regexMatch)
                        return null;
                }
                params = Object.assign(Object.assign({}, params), { [key]: value });
                pathArr[i] = pathnameArr[i];
            }
        });
        path = pathArr.join('/');
    }
    // catch all
    if (path === '*')
        match = [pathname];
    // regular path
    if (!match)
        match = new RegExp(`^${path}`).exec(pathname);
    if (!match)
        return null;
    const url = match[0];
    const isExact = pathname === url;
    if (exact && !isExact)
        return null;
    return {
        path,
        url,
        isExact,
        params
    };
};
class Switch extends component_1.Component {
    constructor() {
        super(...arguments);
        this.index = 0;
        this.path = '';
        this.match = { index: -1, path: '' };
    }
    didMount() {
        window.addEventListener('popstate', this.handlePop.bind(this));
        register(this);
    }
    didUnmount() {
        window.removeEventListener('popstate', this.handlePop.bind(this));
        unregister(this);
    }
    handlePop() {
        this.findChild();
        if (this.shouldUpdate())
            this.update();
    }
    findChild() {
        this.match = { index: -1, path: '' };
        for (let i = 0; i < this.props.children.length; i++) {
            const child = this.props.children[i];
            const { path, exact, regex } = child.props;
            const match = matchPath(typeof isSSR !== 'undefined' ? _nano.location.pathname : window.location.pathname, {
                path,
                exact,
                regex
            });
            if (match) {
                this.match.index = i;
                this.match.path = path;
                return;
            }
        }
    }
    shouldUpdate() {
        return this.path !== this.match.path || this.index !== this.match.index;
    }
    render() {
        this.findChild();
        const child = this.props.children[this.match.index];
        if (this.match.index === -1) {
            this.path = '';
            this.index = 0;
        }
        if (child) {
            const { path } = child.props;
            this.path = path;
            this.index = this.match.index;
            const el = core_1._render(child);
            return core_1._render(el);
        }
        else if (this.props.fallback) {
            return core_1._render(this.props.fallback);
        }
        else {
            return core_1.h('div', { class: 'route' }, 'not found');
        }
    }
}
exports.Switch = Switch;
const Route = ({ path, regex, children }) => {
    // pass the path as props to the children
    children.forEach((child) => {
        if (child.props)
            child.props = Object.assign(Object.assign({}, child.props), { route: { path, regex } });
    });
    return children;
};
exports.Route = Route;
const to = (to, replace = false) => {
    replace ? historyReplace(to) : historyPush(to);
};
exports.to = to;
const Link = ({ to, replace, children }) => {
    const handleClick = (event) => {
        event.preventDefault();
        replace ? historyReplace(to) : historyPush(to);
    };
    return core_1.h('a', { href: to, onClick: (e) => handleClick(e) }, children);
};
exports.Link = Link;
//# sourceMappingURL=router.js.map