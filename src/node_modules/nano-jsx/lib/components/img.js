"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Img = void 0;
const component_1 = require("../component");
const core_1 = require("../core");
class Img extends component_1.Component {
    constructor(props) {
        super(props);
        const { src, key } = props;
        // id has to be unique
        this.id = `${core_1.strToHash(src)}-${core_1.strToHash(JSON.stringify(props))}`;
        if (key)
            this.id += `key-${key}`;
        // this could also be done in willMount()
        if (!this.state)
            this.setState({ isLoaded: false, image: undefined });
    }
    didMount() {
        const _a = this.props, { lazy = true, placeholder, children, key, ref } = _a, rest = __rest(_a, ["lazy", "placeholder", "children", "key", "ref"]);
        if (typeof lazy === 'boolean' && lazy === false)
            return;
        const observer = new IntersectionObserver((entries, observer) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    observer.disconnect();
                    this.state.image = core_1.h('img', Object.assign({}, rest));
                    if (this.state.image.complete) {
                        this.state.isLoaded = true;
                        this.update();
                    }
                    else {
                        this.state.image.onload = () => {
                            this.state.isLoaded = true;
                            this.update();
                        };
                    }
                }
            });
        }, { threshold: [0, 1] });
        observer.observe(this.elements[0]);
    }
    render() {
        const _a = this.props, { src, placeholder, children, lazy = true, key, ref } = _a, rest = __rest(_a, ["src", "placeholder", "children", "lazy", "key", "ref"]);
        // return the img tag if not lazy loaded
        if (typeof lazy === 'boolean' && lazy === false) {
            this.state.image = core_1.h('img', Object.assign({ src }, rest));
            return this.state.image;
        }
        // if it is visible and loaded, show the image
        if (this.state.isLoaded) {
            return this.state.image;
            // if the placeholder is an image src
        }
        else if (placeholder && typeof placeholder === 'string') {
            return core_1.h('img', Object.assign({ src: placeholder }, rest));
            // if the placeholder is an JSX element
        }
        else if (placeholder && typeof placeholder === 'function') {
            return placeholder();
        }
        else {
            // render a simple box
            const style = {};
            if (rest.width)
                style.width = `${rest.width}px`;
            if (rest.height)
                style.height = `${rest.height}px`;
            const { width, height } = rest, others = __rest(rest, ["width", "height"]);
            return core_1.h('div', Object.assign({ style }, others));
        }
    }
}
exports.Img = Img;
//# sourceMappingURL=img.js.map