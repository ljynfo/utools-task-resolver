"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Suspense = void 0;
const component_1 = require("../component");
const core_1 = require("../core");
class Suspense extends component_1.Component {
    constructor(props) {
        super(props);
        this.ready = false;
        // get props promises in ...rest
        const _a = this.props, { children, fallback, cache = false } = _a, rest = __rest(_a, ["children", "fallback", "cache"]);
        // stringify ...rest
        const str = JSON.stringify(rest, function (_key, val) {
            if (typeof val === 'function')
                return `${val}`; // implicitly `toString` it
            return val;
        });
        // create unique id based on ...rest
        this.id = core_1.strToHash(JSON.stringify(str));
    }
    didMount() {
        return __awaiter(this, void 0, void 0, function* () {
            // get props promises in ...rest
            const _a = this.props, { children, fallback, cache = false } = _a, rest = __rest(_a, ["children", "fallback", "cache"]);
            // set initial state to []
            if (cache)
                this.initState = {};
            // check if we already cached the results in this.state
            if (this.loadFromCache(cache))
                return;
            // resolve the promises
            const promises = Object.values(rest).map((p) => p());
            const resolved = yield Promise.all(promises);
            // prepare data
            const data = this.prepareData(rest, resolved, cache);
            // add data to children
            this.addDataToChildren(data);
            // update the component
            this.ready = true;
            this.update();
        });
    }
    ssr() {
        // get props promises in ...rest
        const _a = this.props, { children, fallback, cache = false } = _a, rest = __rest(_a, ["children", "fallback", "cache"]);
        // execute the functions
        const functions = Object.values(rest).map((p) => p());
        // prepare data
        const data = this.prepareData(rest, functions, false);
        // add data to children
        this.addDataToChildren(data);
    }
    loadFromCache(cache) {
        const hasCachedProps = this.state && cache && Object.keys(this.state).length > 0;
        if (hasCachedProps) {
            this.addDataToChildren(this.state);
            this.ready = true;
        }
        return hasCachedProps;
    }
    prepareData(rest, fnc, cache) {
        const data = Object.keys(rest).reduce((obj, item, index) => {
            if (cache)
                this.state = Object.assign(Object.assign({}, this.state), { [item]: fnc[index] });
            return Object.assign(Object.assign({}, obj), { [item]: fnc[index] });
        }, {});
        return data;
    }
    addDataToChildren(data) {
        // add data as props to children
        this.props.children.forEach((child) => {
            if (child.props)
                child.props = Object.assign(Object.assign({}, child.props), data);
        });
    }
    render() {
        // @ts-ignore
        if (typeof isSSR === 'undefined') {
            const { cache = false } = this.props;
            this.loadFromCache(cache);
            return !this.ready ? this.props.fallback : this.props.children;
        }
        else {
            this.ssr();
            return this.props.children;
        }
    }
}
exports.Suspense = Suspense;
//# sourceMappingURL=suspense.js.map