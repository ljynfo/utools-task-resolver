"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.h = exports.renderComponent = exports._render = exports.render = exports.hydrate = exports.appendChildren = exports.strToHash = exports.removeAllChildNodes = exports.tick = void 0;
/** Creates a new Microtask using Promise() */
exports.tick = typeof Promise == 'function' ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout;
// const isDOMElement = (element: any) => {
//   return element && element.tagName && typeof element.tagName === 'string'
// }
const removeAllChildNodes = (parent) => {
    while (parent.firstChild) {
        parent.removeChild(parent.firstChild);
    }
};
exports.removeAllChildNodes = removeAllChildNodes;
// https://stackoverflow.com/a/7616484/12656855
const strToHash = (s) => {
    let hash = 0;
    for (let i = 0; i < s.length; i++) {
        const chr = s.charCodeAt(i);
        hash = (hash << 5) - hash + chr;
        hash |= 0; // Convert to 32bit integer
    }
    return Math.abs(hash).toString(32);
};
exports.strToHash = strToHash;
const appendChildren = (element, children) => {
    // if the child is an html element
    if (!Array.isArray(children)) {
        exports.appendChildren(element, [children]);
        return;
    }
    // htmlCollection to array
    if (typeof children === 'object')
        children = Array.prototype.slice.call(children);
    children.forEach((child) => {
        // if child is an array of children, append them instead
        if (Array.isArray(child))
            exports.appendChildren(element, child);
        else {
            // render the component
            const c = exports._render(child);
            if (typeof c !== 'undefined') {
                // if c is an array of children, append them instead
                if (Array.isArray(c))
                    exports.appendChildren(element, c);
                // apply the component to parent element
                else
                    element.appendChild(c.nodeType == null ? document.createTextNode(c.toString()) : c);
            }
        }
    });
};
exports.appendChildren = appendChildren;
/**
 * A simple component for rendering SVGs
 */
const SVG = (props) => {
    const child = props.children[0];
    const attrs = child.attributes;
    const svg = hNS('svg');
    for (let i = attrs.length - 1; i >= 0; i--) {
        svg.setAttribute(attrs[i].name, attrs[i].value);
    }
    svg.innerHTML = child.innerHTML;
    return svg;
};
const hydrate = (component, parent = null, removeChildNodes = true) => {
    return exports.render(component, parent, removeChildNodes);
};
exports.hydrate = hydrate;
/** Returns the populated parent if available else  one child or an array of children */
const render = (component, parent = null, removeChildNodes = true) => {
    let el = exports._render(component);
    if (Array.isArray(el)) {
        el = el.map(e => exports._render(e));
        if (el.length === 1)
            el = el[0];
    }
    if (parent) {
        if (removeChildNodes)
            exports.removeAllChildNodes(parent);
        // if parent and child are the same, we replace the parent instead of appending to it
        if (el && parent.id && parent.id === el.id && parent.parentElement) {
            parent.parentElement.replaceChild(el, parent);
        }
        else {
            // append element(s) to the parent
            if (Array.isArray(el))
                el.forEach((e) => {
                    exports.appendChildren(parent, exports._render(e));
                    //parent.appendChild(_render(e))
                });
            else
                exports.appendChildren(parent, exports._render(el));
        }
        // @ts-ignore
        if (parent.ssr)
            return parent.ssr;
        return parent;
    }
    // returning one child or an array of children
    else {
        if (typeof isSSR === 'boolean' && isSSR === true && !Array.isArray(el))
            return [el];
        return el;
    }
};
exports.render = render;
const _render = (comp) => {
    // undefined
    if (typeof comp === 'undefined')
        return [];
    // null
    if (comp == null)
        return [];
    // string
    if (typeof comp === 'string')
        return comp;
    // number
    if (typeof comp === 'number')
        return comp.toString();
    // SVGElement
    if (comp.tagName && comp.tagName.toLowerCase() === 'svg')
        return SVG({ children: [comp] });
    // HTMLElement
    if (comp.tagName)
        return comp;
    // Class Component
    if (comp && comp.component && comp.component.isClass && comp.component.isClass())
        return renderClassComponent(comp);
    // Functional Component
    if (comp.component && typeof comp.component === 'function')
        return renderFunctionalComponent(comp);
    // Array (render each child and return the array) (is probably a fragment)
    if (Array.isArray(comp))
        return comp.map(c => exports._render(c)).flat();
    // function
    if (typeof comp === 'function')
        return exports._render(comp());
    // if component is a HTMLElement (rare case)
    if (comp.component && comp.component.tagName && typeof comp.component.tagName === 'string')
        return exports._render(comp.component);
    // (rare case)
    if (Array.isArray(comp.component))
        return exports._render(comp.component);
    // (rare case)
    if (comp.component)
        return exports._render(comp.component);
    // object
    if (typeof comp === 'object')
        return [];
    console.warn('Something unexpected happened with:', comp);
};
exports._render = _render;
const renderFunctionalComponent = (fncComp) => {
    const { component, props } = fncComp;
    return exports._render(component(props));
};
const renderClassComponent = (classComp) => {
    const { component, props } = classComp;
    // calc hash
    const hash = exports.strToHash(component.toString());
    // make hash accessible in constructor, without passing it to it
    component.prototype._getHash = () => hash;
    const Component = new component(props);
    Component.willMount();
    let el = Component.render();
    el = exports._render(el);
    Component.elements = el;
    // pass the component instance as ref
    if (props && props.ref)
        props.ref(Component);
    if (typeof isSSR === 'undefined')
        exports.tick(() => {
            Component._didMount();
        });
    return el;
};
/** @deprecated renderComponent() is deprecated, use _render() instead! */
const renderComponent = (_component) => {
    console.warn('DEPRECATED: renderComponent() is deprecated, use _render() instead!');
    // this fixes some ssr issues when using fragments
    // if (typeof isSSR === 'boolean' && isSSR === true && Array.isArray(el)) {
    //   el = el
    //     .map((e) => {
    //       return _render(e)
    //     })
    //     .join('')
    // }
};
exports.renderComponent = renderComponent;
const hNS = (tag) => document.createElementNS('http://www.w3.org/2000/svg', tag);
// https://stackoverflow.com/a/42405694/12656855
const h = (tagNameOrComponent, props, ...children) => {
    // if tagNameOrComponent is a component
    if (typeof tagNameOrComponent !== 'string')
        return { component: tagNameOrComponent, props: Object.assign(Object.assign({}, props), { children: children }) };
    let ref;
    const element = tagNameOrComponent === 'svg'
        ? hNS('svg')
        : document.createElement(tagNameOrComponent);
    // check if the element includes the event (for example 'oninput')
    const isEvent = (el, p) => {
        // check if the event begins with 'on'
        if (0 !== p.indexOf('on'))
            return false;
        // we return true if SSR, since otherwise it will get rendered
        if (el.ssr)
            return true;
        // check if the event is present in the element as object (null) or as function
        return typeof el[p] === 'object' || typeof el[p] === 'function';
    };
    for (const p in props) {
        // https://stackoverflow.com/a/45205645/12656855
        // style object to style string
        if (p === 'style' && typeof props[p] === 'object') {
            const styles = Object.keys(props[p])
                .map(k => `${k}:${props[p][k]}`)
                .join(';')
                .replace(/[A-Z]/g, match => `-${match.toLowerCase()}`);
            props[p] = `${styles};`;
        }
        // handel ref
        if (p === 'ref')
            ref = props[p];
        // handle events
        else if (isEvent(element, p.toLowerCase()))
            element.addEventListener(p.toLowerCase().substring(2), (e) => props[p](e));
        else if (/className/i.test(p))
            console.warn('You can use "class" instead of "className".');
        else
            element.setAttribute(p, props[p]);
    }
    exports.appendChildren(element, children);
    if (ref)
        ref(element);
    // @ts-ignore
    if (element.ssr)
        return element.ssr;
    return element;
};
exports.h = h;
//# sourceMappingURL=core.js.map