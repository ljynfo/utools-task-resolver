"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Snackbar = void 0;
const core_1 = require("../core");
const _config_1 = require("./_config");
class Snackbar {
    constructor(options = {}) {
        this.options = options;
        this.defaultParentId = 'snackbar_container';
        this.defaultActionColor = '#BC86FC';
        const defaultOptions = {
            message: 'Hello Snack!',
            actions: [{ name: 'Dismiss', color: this.defaultActionColor }],
            autoHide: true,
            consecutive: true,
            offsetY: 0
        };
        this.options = Object.assign(Object.assign({}, defaultOptions), options);
        // styles
        const styles = `
      #snackbar_container {    
        position: fixed;
        bottom: ${this.options.offsetY}px;
        left: 0px;
        overflow: hidden;
        z-index: ${_config_1.zIndex.snackbar}
      }

      #snackbar_container .snackbar_snack {
        background-color: #323232;

        padding: 16px 16px 16px 16px;
        margin: 0px 8px 8px 8px;

        border-radius: 4px;
        width: 344px;
        max-width: calc(100vw - 16px);
        box-sizing: border-box;
        display: flex;
        justify-content: space-between;
        height: fit-content;
        overflow: hidden;

        ${_config_1.boxShadow}

        animation-name: snackbar-fadein;
        animation-duration: 0.2s;

        transition: opacity 0.2s;
        opacity: 1;
      }

      #snackbar_container .snackbar_snack_fadeout {
        opacity: 0;
      } 

      #snackbar_container .snackbar_snack .snackbar_message {
        color: #DFDFDF;
        font-size: 16px;
        align-self: center;
      }

      #snackbar_container .snackbar_snack .snackbar_actions {
        align-self: center;
      }

      #snackbar_container .snackbar_snack .snackbar_action {
        font-size: 16px;
        cursor: pointer;
        padding: 8px;
        margin-right: -8px;
      }

      @keyframes snackbar-fadein {
        from {opacity: 0;}
        to {opacity: 1;}
      }
    `;
        document.head.appendChild(core_1.h('style', {}, styles));
    }
    getParentElement(parentId) {
        let el = document.getElementById(parentId || this.defaultParentId);
        if (!el) {
            el = document.createElement('div');
            el.id = this.defaultParentId;
            document.body.appendChild(el);
        }
        return el;
    }
    remove(el) {
        el.classList.add('snackbar_snack_fadeout');
        setTimeout(() => el.remove(), 200);
    }
    show(options, callback) {
        if (this.options.consecutive) {
            const snacks = document.querySelectorAll('.snackbar_snack');
            snacks.forEach(s => this.remove(s));
            if (snacks.length > 0)
                setTimeout(() => this._show(options, callback), 200 + 20);
            else
                this._show(options, callback);
            return;
        }
        this._show(options, callback);
    }
    _show(options, callback) {
        options = Object.assign(Object.assign({}, this.options), options);
        const container = this.getParentElement(options.parentId || this.defaultParentId);
        const Snack = (_message, _actions) => {
            const actionsArray = _actions.map((action) => {
                return core_1.h('a', {
                    class: 'snackbar_action',
                    style: `color: ${action.color || this.defaultActionColor}`,
                    onClick: () => {
                        callback({ name: action.name, id: action.id });
                        this.remove(el);
                    }
                }, action.name.toUpperCase());
            });
            const message = core_1.h('div', { class: 'snackbar_message' }, _message);
            const actions = core_1.h('div', { class: 'snackbar_actions' }, actionsArray);
            const snack = core_1.h('div', { class: 'snackbar_snack' }, message, actions);
            return snack;
        };
        const el = Snack(options.message, options.actions || []);
        // autoHide options
        if (options.autoHide === true)
            setTimeout(() => this.remove(el), 5000);
        else if (typeof options.autoHide === 'number')
            setTimeout(() => this.remove(el), options.autoHide);
        container.appendChild(el);
    }
}
exports.Snackbar = Snackbar;
//# sourceMappingURL=snackbar.js.map